# 2026-01-11 — StillRoot API v1：愿景与产品逻辑（CEO+CTO+PM 视角）

本文是对「StillRoot 标准 API + PAT + 一键复制给 Agent」这一迭代的产品分析与长期愿景阐述，用于对齐后续路线与取舍标准。

## 一句话愿景

StillRoot 不是“写笔记的地方”，而是一个 **人类思考与 agent 行动共享的知识底座**：思考落地为结构化数据，agent 通过标准协议可靠地读写与执行，形成闭环。

## 这个功能到底在解决什么

我们最近交付的核心不是“多了几个接口”，而是把产品从单体 UI 工具升级为平台能力：

- **标准 API（StillRoot API v1）**：把笔记/消息变成可编程资产（programmable notes）。
- **PAT（个人访问令牌）**：把第三方访问从“分享账号/主登录态”升级为“可控授权钥匙”。
- **一键复制给 Agent**：把接入成本压到最低，让用户能把自己的知识库立即接入 Cursor / Claude / Codex 等外部工具。

## 为什么是 channels + messages 这两个模型

我们刻意收敛能力边界，只保证 agent 的核心工作流：

- `channels` = “主题/项目/空间”的稳定容器（可被列出、选择、聚合）
- `messages` = “时间线事实流”（最适合 agent 做摘要、回放、增量同步、对话式写入）

这套模型的优势：

- 更适合增量同步（cursor pagination）与幂等写入（Idempotency-Key）
- 更容易做治理（权限、审计、计费）与未来扩展（搜索、embedding、工作流）
- 强约束：messages 必须携带 `channelId`，避免“无边界抓取”式接口导致隐私面失控

## 为什么要 PAT（对标 GitHub）

对标 GitHub 的 “Personal Access Token” 模式，我们的核心要求是：

- **控制权在用户**：用户能创建、撤销、限制权限（scopes）、设置过期
- **避免暴露主登录态**：外部工具不拿 Firebase 登录态，只拿 PAT
- **可运维**：未来出现异常行为可以撤销单个 PAT，而不是让用户整账号退出

结论：PAT 是平台化不可绕开的“对外授权原语”，是生态与商业化的基础设施。

## 为什么要“一键复制给 Agent”

产品上我们追求的体验是：用户只做一次动作，agent 就能立即工作。

我们选择把以下信息一次性打包：

- `baseUrl`：接口入口
- `openapiUrl`：机器可读规范（让 agent 自动理解所有 endpoint/参数）
- `token`：PAT（外部调用凭证）
- `scopes / expiresAt`：可治理的授权约束
- 最短“规则说明”：所有请求带 Bearer；先 channels 后 messages；messages 必带 channelId

这相当于把“接入文档 + 配置文件 + 最佳实践”压缩成一段可直接粘贴给 agent 的内容。

## 面向未来的路线（建议顺序）

### 阶段 1：只读 agent（价值最大、风险最小）

- `GET /v1/channels`
- `GET /v1/messages?channelId=...`
- 目标：让 agent 先能“理解你在写什么”，做摘要、回顾、问答、周报

### 阶段 2：可写 agent（闭环开始形成）

- `POST /v1/messages`（强制 channelId + 幂等）
- 目标：让 agent 能把结果回写 StillRoot，形成“思考—行动—回写”的闭环

### 阶段 3：工作流与治理（平台化关键）

- 最先做的不是更多 endpoint，而是能力中台：
  - 审计日志（PAT 使用、写入行为）
  - 速率限制/配额
  - 更细粒度 scopes（例如 channel 级别授权）
  - 搜索/索引/embedding（支持 agent 高效检索）

## 取舍标准（长期不变）

- **隐私面最小化**：不做“可有可无”的接口；只做能让 agent 真正工作起来的最小集合。
- **唯一性**：同一个能力不在多处重复实现；API 与 UI 的逻辑边界清晰。
- **UI 组件不依赖业务逻辑**：UI 只负责展示与交互，业务在 service/store 层统一。
- **工程可持续**：每次阶段性迭代都必须有可复验的验证方式（typecheck/lint/build）。

## 当前阶段的“成功标准”

当以下三件事稳定成立，就说明 v1 已经从“能跑”进入“可用”：

1) 用户创建 PAT 后，刷新/重新进入界面仍能看到 token 元信息（可撤销）
2) 外部工具拿到复制内容后，无需手工对齐参数即可成功调用 channels/messages
3) 同一个 PAT 可重复调用，不会出现“一次性失效”、索引阻塞、部署不可控的问题

## 用户价值（不是抽象概念）

这套能力对用户的“可感知价值”，最终必须落到具体结果上：

- **把“笔记”变成“可调用的私有知识库”**：用户可以把某个任务交给 agent，让它直接读自己的历史信息来完成（而不是让用户反复口述背景）。
- **把“零散记录”变成“可产出”**：周报/复盘/汇报/内容创作的素材提取，来自真实时间线（messages），可持续迭代。
- **把“个人系统”扩展为“工具生态”**：用户不需要等 StillRoot 内置所有功能，外部工具可以先通过 API 接入，StillRoot 只负责做稳定底座。

把这三点合并成一句话：用户买到的是“我自己专属的、可被 agent 使用的记忆与上下文”，而不是几个 HTTP endpoint。

## 入口位置（信息架构决策）

API 访问（PAT 管理 / 一键复制给 Agent）是 **全局级能力**：

- 它授权的是“账号/知识库”的对外访问，而不是某一个 space/channel 的功能开关。
- 用户的心智模型应该是：**我给外部工具一个钥匙（PAT）**，它能按 scopes 访问；至于访问哪个 channel，是调用时选择的，不是“在某个空间里配置”。

因此入口应该放在 **时间线 Header 左上角的全局菜单**（全局一致、随处可达、不会被误认为是空间设置）。

## “一键复制给 Agent”的终极体验（用户视角）

用户不应该去理解 OpenAPI、Base URL、Bearer token 这些概念。我们要让用户做到：

1) 打开全局菜单 → 进入 API 访问
2) 点击“生成/管理 Token” → 选择权限与有效期
3) 点击“一键复制给 Agent” → 粘贴给任意 agent（或工具）即可开始工作

用户只需要知道一句话：**“把这段内容发给你的 agent，它就能读写你的 StillRoot。”**

## 我们未来最重要的“产品护城河”

不在于接口越来越多，而在于这套底座能让用户长期依赖：

- **可控授权**：token 可撤销、可过期、可限权，避免“绑死账号登录态”
- **可靠体验**：同一 token 可重复调用；错误信息可定位；本地/线上部署一套逻辑
- **可迁移与可扩展**：标准 API + OpenAPI 让生态自然生长，StillRoot 只要稳就赢
